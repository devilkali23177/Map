<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Advanced Mind Map with Firebase Integration</title>
  <!-- Add Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
  <style>
    /* Your existing CSS styles remain unchanged */
    body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      margin: 0; 
      overflow: hidden; 
      background: #111; 
      color: #fff; 
      touch-action: none;
    }
    #toolbar { 
      padding: 8px; 
      background: #222; 
      position: fixed; 
      top: 0; 
      left: 0; 
      right: 0; 
      z-index: 10; 
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.5);
    }
    #toolbar button, #toolbar select, #toolbar input { 
      padding: 10px 14px;
      background: #444; 
      color: white;
      border: 1px solid #666;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      min-height: 20px;
    }
    #toolbar button:hover, #toolbar select:hover {
      background: #555;
    }
    #toolbar button.active {
      background: #2a6b9b;
    }
    #toolbar input {
      background: #333;
      width: 100px;
      min-height: 20px;
    }
    #toolbar .separator {
      width: 1px;
      background: #444;
      margin: 0 8px;
      height: 24px;
    }
    #stage { 
      position: absolute; 
      top: 50px;
      left: 0; 
      right: 0; 
      bottom: 0; 
      overflow: auto; 
      -webkit-overflow-scrolling: touch;
    }
    #world { 
      position: relative; 
      width: 100000000000000000000000000000000000000000000000000000000000000000000px; 
      height: 100000000000000000000000000000000000000000000000000000000000000000000px; 
      transform-origin: 0 0;
      transition: transform 0.1s ease;
    }
    .node { 
      position: absolute; 
      min-width: 130px;
      max-width: 250px;
      padding: 12px 16px;
      background: #333; 
      border: 2px solid #666;
      border-radius: 10px;
      cursor: grab; 
      user-select: none; 
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      overflow: hidden;
      text-overflow: ellipsis;
      transition: transform 0.1s ease;
      font-size: 16px;
      touch-action: none;
    }
    .node:hover {
      transform: scale(1.02);
    }
    .node.selected { 
      border-color: #0ff; 
      box-shadow: 0 0 10px rgba(0,255,255,0.5);
    }
    .node.dragging {
      cursor: grabbing;
      opacity: 0.9;
    }
    .node-content {
      min-height: 24px;
      word-wrap: break-word;
    }
    svg { 
      position: absolute; 
      inset: 0; 
      pointer-events: none; 
    }
    line.connection {
      stroke: #0ff;
      stroke-width: 2;
    }
    line.connection.highlight {
      stroke: #ff0;
      stroke-width: 3;
    }
    #zoom-display {
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: rgba(0,0,0,0.5);
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 14px;
      z-index: 5;
    }
    .context-menu {
      position: fixed;
      background: #333;
      border: 1px solid #555;
      border-radius: 4px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
      z-index: 100;
      min-width: 150px;
    }
    .context-menu-item {
      padding: 12px 16px;
      cursor: pointer;
      font-size: 16px;
    }
    .context-menu-item:hover {
      background: #444;
    }
    .color-picker {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      padding: 10px;
      width: 140px;
    }
    .color-option {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid #555;
    }
    .node-edit-input {
      position: absolute;
      background: #222;
      border: 2px solid #0ff;
      border-radius: 6px;
      padding: 8px;
      color: white;
      font: inherit;
      z-index: 20;
      min-width: 120px;
      resize: both;
      overflow: auto;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
      font-size: 16px;
    }
    #edit-panel {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #333;
      border: 2px solid #0ff;
      border-radius: 8px;
      padding: 20px;
      z-index: 100;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
      width: 320px;
      display: none;
    }
    #edit-panel h3 {
      margin-top: 0;
      color: #0ff;
      border-bottom: 1px solid #555;
      padding-bottom: 10px;
      font-size: 18px;
    }
    #edit-textarea {
      width: 100%;
      height: 120px;
      background: #222;
      color: white;
      border: 1px solid #555;
      border-radius: 4px;
      padding: 10px;
      resize: vertical;
      margin-bottom: 15px;
      font-family: inherit;
      font-size: 16px;
    }
    #edit-panel-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }
    #edit-panel button {
      padding: 10px 18px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      min-width: 80px;
    }
    #edit-panel-save {
      background: #2a6b9b;
      color: white;
    }
    #edit-panel-cancel {
      background: #555;
      color: white;
    }
    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      z-index: 90;
      display: none;
    }
    
    /* Firebase auth UI */
    #auth-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    #auth-box {
      background: #333;
      padding: 30px;
      border-radius: 10px;
      width: 300px;
      text-align: center;
    }
    #auth-box h2 {
      margin-top: 0;
      color: #0ff;
    }
    #auth-box input {
      width: 100%;
      padding: 12px;
      margin: 10px 0;
      border: 1px solid #555;
      border-radius: 4px;
      background: #222;
      color: white;
      box-sizing: border-box;
    }
    #auth-box button {
      width: 100%;
      padding: 12px;
      margin: 5px 0;
      border: none;
      border-radius: 4px;
      background: #2a6b9b;
      color: white;
      cursor: pointer;
    }
    #auth-box p {
      margin: 15px 0 5px;
      color: #aaa;
    }
    #auth-message {
      color: #e74c3c;
      margin: 10px 0;
      min-height: 20px;
    }
    
    /* Mind Map Manager UI */
    #map-manager-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      display: none;
    }
    #map-manager-box {
      background: #333;
      padding: 30px;
      border-radius: 10px;
      width: 500px;
      max-width: 90%;
      max-height: 80%;
      overflow-y: auto;
    }
    #map-manager-box h2 {
      margin-top: 0;
      color: #0ff;
      border-bottom: 1px solid #555;
      padding-bottom: 10px;
    }
    #map-list {
      margin: 20px 0;
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #555;
      border-radius: 4px;
      background: #222;
    }
    .map-item {
      padding: 12px 16px;
      border-bottom: 1px solid #444;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .map-item:hover {
      background: #3a3a3a;
    }
    .map-item.active {
      background: #2a6b9b;
    }
    .map-item-actions {
      display: flex;
      gap: 8px;
    }
    .map-item-actions button {
      padding: 6px 10px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    .map-item-actions .delete-btn {
      background: #e74c3c;
      color: white;
    }
    .map-item-actions .rename-btn {
      background: #f39c12;
      color: white;
    }
    #new-map-form {
      display: flex;
      gap: 10px;
      margin: 20px 0;
    }
    #new-map-input {
      flex: 1;
      padding: 10px;
      background: #222;
      color: white;
      border: 1px solid #555;
      border-radius: 4px;
    }
    #create-map-btn {
      padding: 10px 16px;
      background: #2ecc71;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    #close-map-manager {
      width: 100%;
      padding: 12px;
      background: #555;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 10px;
    }
    
    /* Mobile-specific styles */
    @media (max-width: 768px) {
      #toolbar {
        padding: 6px;
        gap: 4px;
        overflow-x: auto;
        white-space: nowrap;
        height: 44px;
      }
      #toolbar button, #toolbar select, #toolbar input {
        padding: 8px 10px;
        font-size: 13px;
      }
      #stage {
        top: 46px;
      }
      .node {
        min-width: 110px;
        padding: 10px 12px;
        font-size: 15px;
      }
      #zoom-display {
        bottom: 5px;
        right: 5px;
        font-size: 12px;
        padding: 4px 8px;
      }
      #auth-box {
        width: 90%;
        max-width: 300px;
      }
      #map-manager-box {
        width: 90%;
        padding: 20px;
      }
      .map-item {
        padding: 10px 12px;
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
      }
      .map-item-actions {
        align-self: flex-end;
      }
    }
    
    /* Prevent text selection on UI elements */
    .node, #toolbar button, .context-menu-item {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    
    /* Long press detection style */
    .long-press {
      animation: pulse 0.8s infinite alternate;
    }
    @keyframes pulse {
      from { transform: scale(1); }
      to { transform: scale(1.05); }
    }
  </style>
</head>
<body>
  <!-- Firebase Auth UI -->
  <div id="auth-container">
    <div id="auth-box">
      <h2>Mind Map Login</h2>
      <div id="auth-message"></div>
      <input type="email" id="email-input" placeholder="Email">
      <input type="password" id="password-input" placeholder="Password">
      <button id="login-btn">Login</button>
      <button id="signup-btn">Sign Up</button>
      <p>Or continue as</p>
      <button id="guest-btn">Guest</button>
    </div>
  </div>

  <!-- Mind Map Manager UI -->
  <div id="map-manager-container">
    <div id="map-manager-box">
      <h2>Manage Mind Maps</h2>
      <div id="new-map-form">
        <input type="text" id="new-map-input" placeholder="New map name">
        <button id="create-map-btn">Create New Map</button>
      </div>
      <div id="map-list">
        <!-- Map items will be added here dynamically -->
      </div>
      <button id="close-map-manager">Close</button>
    </div>
  </div>

  <div id="toolbar">
    <button id="addBtn">Add Node</button>
    <button id="connectBtn">Connect Nodes</button>
    <button id="editBtn">Edit Node</button>
    <button id="deleteBtn">Delete</button>
    <div class="separator"></div>
    <button id="zoomInBtn">Zoom In</button>
    <button id="zoomOutBtn">Zoom Out</button>
    <button id="resetViewBtn">Reset View</button>
    <div class="separator"></div>
    <button id="colorBtn">Color</button>
    <button id="exportBtn">Export</button>
    <button id="importBtn">Import</button>
    <div class="separator"></div>
    <select id="layoutBtn">
      <option value="">Layout</option>
      <option value="horizontal">Horizontal</option>
      <option value="vertical">Vertical</option>
      <option value="radial">Radial</option>
    </select>
    <input type="text" id="searchInput" placeholder="Search nodes...">
    <div class="separator"></div>
    <button id="saveBtn">Save to Cloud</button>
    <button id="loadBtn">Load from Cloud</button>
    <button id="mapsBtn">Manage Maps</button>
    <button id="logoutBtn" style="display:none;">Logout</button>
  </div>
  <div id="stage">
    <div id="world">
      <svg id="edges" width="100000000000000000000000000000000000000000000000000000000000000000000" height="100000000000000000000000000000000000000000000000000000000000000000000"></svg>
    </div>
  </div>
  <div id="zoom-display">100%</div>
  
  <!-- Edit Panel -->
  <div id="overlay"></div>
  <div id="edit-panel">
    <h3>Edit Node Content</h3>
    <textarea id="edit-textarea"></textarea>
    <div id="edit-panel-buttons">
      <button id="edit-panel-cancel">Cancel</button>
      <button id="edit-panel-save">Save</button>
    </div>
  </div>
  
  <script>
    // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyBlQI16Nmx5oo3VzyCDEb6V4M2cH9Bbwc8",
      authDomain: "mindmapping-58435.firebaseapp.com",
      databaseURL: "https://mindmapping-58435-default-rtdb.firebaseio.com",
      projectId: "mindmapping-58435",
      storageBucket: "mindmapping-58435.firebasestorage.app",
      messagingSenderId: "1059085761579",
      appId: "1:1059085761579:web:5422cefb56f5989af7be6e",
      measurementId: "G-9F7EZZ2C9T"
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const database = firebase.database();
    const auth = firebase.auth();
    
    // Main application variables
    const world = document.getElementById('world');
    const edgesSVG = document.getElementById('edges');
    let nodes = {};
    let edges = [];
    let idCounter = 1;
    let connectMode = false;
    let editMode = false;
    let connectFrom = null;
    let selectedNode = null;
    let scale = 1;
    let panning = false;
    let startX, startY;
    let initialPinchDistance = null;
    let lastX = 0, lastY = 0;
    let activeEditInput = null;
    let longPressTimer = null;
    let isLongPress = false;
    let currentUser = null;
    let currentMapId = 'default';
    let mindMaps = {}; // Store all user's mind maps
    
    // New variables for fixing node dragging
    let isDraggingNode = false;
    let initialTouchPositions = null;
    
    // New variables for improved zooming
    let worldX = 0;
    let worldY = 0;
    let zoomPointX = 0;
    let zoomPointY = 0;
    let isZooming = false;
    
    // Initialize the application
    function init() {
      // Setup auth event listeners
      setupAuthEventListeners();
      
      // Check if user was previously logged in
      const savedUser = localStorage.getItem('mindmap_user');
      if (savedUser) {
        try {
          currentUser = JSON.parse(savedUser);
          document.getElementById('auth-container').style.display = 'none';
          document.getElementById('logoutBtn').style.display = 'block';
          initApp();
        } catch (e) {
          console.error('Error parsing saved user:', e);
          localStorage.removeItem('mindmap_user');
        }
      }
    }
    
    // Initialize the app after authentication
    function initApp() {
      // Add event listeners
      setupEventListeners();
      
      // Load list of mind maps
      loadMindMapsList();
      
      // Try to load from Firebase
      loadFromFirebase();
      
      // If no data, add initial node
      if (Object.keys(nodes).length === 0) {
        addNode(500, 500, 'Main Topic');
      }
      
      // Update zoom display
      updateZoomDisplay();
    }
    
    // Set up authentication event listeners
    function setupAuthEventListeners() {
      document.getElementById('login-btn').onclick = handleLogin;
      document.getElementById('signup-btn').onclick = handleSignup;
      document.getElementById('guest-btn').onclick = handleGuest;
      document.getElementById('logoutBtn').onclick = handleLogout;
      
      // Allow submitting with Enter key
      document.getElementById('email-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') handleLogin();
      });
      document.getElementById('password-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') handleLogin();
      });
    }
    
    // Handle user login
    function handleLogin() {
      const email = document.getElementById('email-input').value;
      const password = document.getElementById('password-input').value;
      const authMessage = document.getElementById('auth-message');
      
      if (!email || !password) {
        authMessage.textContent = 'Please enter both email and password';
        return;
      }
      
      authMessage.textContent = 'Logging in...';
      
      auth.signInWithEmailAndPassword(email, password)
        .then((userCredential) => {
          currentUser = userCredential.user;
          localStorage.setItem('mindmap_user', JSON.stringify({
            uid: currentUser.uid,
            email: currentUser.email
          }));
          document.getElementById('auth-container').style.display = 'none';
          document.getElementById('logoutBtn').style.display = 'block';
          authMessage.textContent = '';
          initApp();
        })
        .catch((error) => {
          authMessage.textContent = error.message;
        });
    }
    
    // Handle user signup
    function handleSignup() {
      const email = document.getElementById('email-input').value;
      const password = document.getElementById('password-input').value;
      const authMessage = document.getElementById('auth-message');
      
      if (!email || !password) {
        authMessage.textContent = 'Please enter both email and password';
        return;
      }
      
      if (password.length < 6) {
        authMessage.textContent = 'Password should be at least 6 characters';
        return;
      }
      
      authMessage.textContent = 'Creating account...';
      
      auth.createUserWithEmailAndPassword(email, password)
        .then((userCredential) => {
          currentUser = userCredential.user;
          localStorage.setItem('mindmap_user', JSON.stringify({
            uid: currentUser.uid,
            email: currentUser.email
          }));
          document.getElementById('auth-container').style.display = 'none';
          document.getElementById('logoutBtn').style.display = 'block';
          authMessage.textContent = '';
          initApp();
        })
        .catch((error) => {
          authMessage.textContent = error.message;
        });
    }
    
    // Handle guest access
    function handleGuest() {
      currentUser = { uid: 'guest', email: 'guest@example.com' };
      document.getElementById('auth-container').style.display = 'none';
      initApp();
    }
    
    // Handle user logout
    function handleLogout() {
      auth.signOut().then(() => {
        currentUser = null;
        localStorage.removeItem('mindmap_user');
        document.getElementById('logoutBtn').style.display = 'none';
        document.getElementById('auth-container').style.display = 'flex';
        
        // Clear current mind map
        nodes = {};
        edges = [];
        idCounter = 1;
        world.querySelectorAll('.node').forEach(n => n.remove());
        edgesSVG.innerHTML = '';
        clearSelection();
      }).catch((error) => {
        console.error('Logout error:', error);
      });
    }
    
    // Set up all event listeners
    function setupEventListeners() {
      // Toolbar buttons
      document.getElementById('addBtn').onclick = () => {
        const x = 500 + Math.random() * 400;
        const y = 500 + Math.random() * 400;
        addNode(x, y, 'New Node');
        saveToFirebase(); // Auto-save after adding node
      };
      
      document.getElementById('connectBtn').onclick = () => {
        connectMode = !connectMode;
        editMode = false;
        document.getElementById('connectBtn').classList.toggle('active', connectMode);
        document.getElementById('editBtn').classList.remove('active');
        connectFrom = null;
        clearSelection();
      };
      
      document.getElementById('editBtn').onclick = () => {
        editMode = !editMode;
        connectMode = false;
        document.getElementById('editBtn').classList.toggle('active', editMode);
        document.getElementById('connectBtn').classList.remove('active');
      };
      
      document.getElementById('deleteBtn').onclick = () => {
        deleteSelected();
        saveToFirebase(); // Auto-save after deletion
      };
      
      document.getElementById('zoomInBtn').onclick = () => adjustZoom(0.1, window.innerWidth/2, window.innerHeight/2);
      document.getElementById('zoomOutBtn').onclick = () => adjustZoom(-0.1, window.innerWidth/2, window.innerHeight/2);
      document.getElementById('resetViewBtn').onclick = resetView;
      
      document.getElementById('colorBtn').onclick = showColorMenu;
      document.getElementById('exportBtn').onclick = exportData;
      document.getElementById('importBtn').onclick = () => document.getElementById('importInput')?.click() || createImportInput();
      
      document.getElementById('layoutBtn').onchange = (e) => {
        if (e.target.value) {
          applyLayout(e.target.value);
          saveToFirebase(); // Auto-save after layout change
        }
      };
      
      document.getElementById('searchInput').oninput = (e) => {
        searchNodes(e.target.value);
      };
      
      // Firebase save/load buttons
      document.getElementById('saveBtn').onclick = saveToFirebase;
      document.getElementById('loadBtn').onclick = loadFromFirebase;
      
      // Map management button
      document.getElementById('mapsBtn').onclick = showMapManager;
      
      // Edit panel buttons
      document.getElementById('edit-panel-save').onclick = () => {
        saveEditPanel();
        saveToFirebase(); // Auto-save after editing
      };
      document.getElementById('edit-panel-cancel').onclick = closeEditPanel;
      document.getElementById('overlay').onclick = closeEditPanel;
      
      // Map manager event listeners
      document.getElementById('create-map-btn').onclick = createNewMap;
      document.getElementById('close-map-manager').onclick = hideMapManager;
      
      // Allow Enter key to create new map
      document.getElementById('new-map-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') createNewMap();
      });
      
      // Panning and zooming
      world.addEventListener('wheel', handleWheel, { passive: false });
      world.addEventListener('mousedown', startPan);
      document.addEventListener('mousemove', handlePan);
      document.addEventListener('mouseup', stopPan);
      
      // Touch events for mobile
      setupTouchEvents();
      
      // Context menu
      world.addEventListener('contextmenu', handleContextMenu);
      
      // Click outside to clear selection
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.node') && !e.target.closest('.context-menu') && 
            !e.target.closest('.node-edit-input') && !e.target.closest('#edit-panel') &&
            !e.target.closest('#map-manager-container')) {
          clearSelection();
          hideContextMenu();
        }
      });
      
      // Double click to edit
      world.addEventListener('dblclick', (e) => {
        const node = e.target.closest('.node');
        if (node) {
          const nodeId = node.dataset.id;
          selectNode(nodeId);
          showEditPanel(nodes[nodeId]);
        }
      });
      
      // Auto-save on node drag end
      document.addEventListener('mouseup', () => {
        if (isDraggingNode) {
          saveToFirebase();
          isDraggingNode = false;
        }
      });
    }
    
    // Save mind map to Firebase
    function saveToFirebase() {
      if (!currentUser) return;
      
      const data = {
        nodes: Object.values(nodes),
        edges: edges,
        idCounter: idCounter,
        lastUpdated: Date.now(),
        name: currentMapId === 'default' ? 'Default Map' : currentMapId
      };
      
      const userPath = currentUser.uid === 'guest' ? 'guest_maps' : `users/${currentUser.uid}/maps`;
      
      database.ref(`${userPath}/${currentMapId}`).set(data)
        .then(() => {
          console.log('Data saved successfully to Firebase');
          // Show a temporary save confirmation
          const saveBtn = document.getElementById('saveBtn');
          const originalText = saveBtn.textContent;
          saveBtn.textContent = 'Saved!';
          setTimeout(() => {
            saveBtn.textContent = originalText;
          }, 2000);
          
          // Refresh the map list to show updated timestamp
          loadMindMapsList();
        })
        .catch((error) => {
          console.error('Error saving data to Firebase:', error);
          alert('Failed to save to cloud: ' + error.message);
        });
    }
    
    // Load mind map from Firebase
    function loadFromFirebase() {
      if (!currentUser) return;
      
      const userPath = currentUser.uid === 'guest' ? 'guest_maps' : `users/${currentUser.uid}/maps`;
      
      database.ref(`${userPath}/${currentMapId}`).once('value')
        .then((snapshot) => {
          const data = snapshot.val();
          if (data) {
            loadData(data);
            console.log('Data loaded successfully from Firebase');
          } else {
            console.log('No data found in Firebase, using local data');
            // Create a new empty map if none exists
            if (Object.keys(nodes).length === 0) {
              addNode(500, 500, 'Main Topic');
            }
          }
        })
        .catch((error) => {
          console.error('Error loading data from Firebase:', error);
          alert('Failed to load from cloud: ' + error.message);
        });
    }
    
    // Load list of all mind maps for the current user
    function loadMindMapsList() {
      if (!currentUser) return;
      
      const userPath = currentUser.uid === 'guest' ? 'guest_maps' : `users/${currentUser.uid}/maps`;
      
      database.ref(userPath).once('value')
        .then((snapshot) => {
          const maps = snapshot.val();
          mindMaps = maps || {};
          renderMapsList();
        })
        .catch((error) => {
          console.error('Error loading mind maps list:', error);
        });
    }
    
    // Render the list of mind maps in the manager UI
    function renderMapsList() {
      const mapList = document.getElementById('map-list');
      mapList.innerHTML = '';
      
      if (!mindMaps || Object.keys(mindMaps).length === 0) {
        mapList.innerHTML = '<div class="map-item" style="justify-content: center; cursor: default;">No maps found</div>';
        return;
      }
      
      Object.entries(mindMaps).forEach(([mapId, mapData]) => {
        const mapItem = document.createElement('div');
        mapItem.className = 'map-item';
        if (mapId === currentMapId) {
          mapItem.classList.add('active');
        }
        
        const mapName = document.createElement('div');
        mapName.className = 'map-name';
        mapName.textContent = mapData.name || mapId;
        
        const mapInfo = document.createElement('div');
        mapInfo.className = 'map-info';
        mapInfo.textContent = new Date(mapData.lastUpdated).toLocaleString();
        
        const mapActions = document.createElement('div');
        mapActions.className = 'map-item-actions';
        
        const loadBtn = document.createElement('button');
        loadBtn.textContent = 'Load';
        loadBtn.onclick = (e) => {
          e.stopPropagation();
          switchToMap(mapId);
        };
        
        const renameBtn = document.createElement('button');
        renameBtn.textContent = 'Rename';
        renameBtn.className = 'rename-btn';
        renameBtn.onclick = (e) => {
          e.stopPropagation();
          renameMap(mapId);
        };
        
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'Delete';
        deleteBtn.className = 'delete-btn';
        deleteBtn.onclick = (e) => {
          e.stopPropagation();
          deleteMap(mapId);
        };
        
        mapActions.appendChild(loadBtn);
        mapActions.appendChild(renameBtn);
        mapActions.appendChild(deleteBtn);
        
        mapItem.appendChild(mapName);
        mapItem.appendChild(mapInfo);
        mapItem.appendChild(mapActions);
        
        mapList.appendChild(mapItem);
      });
    }
    
    // Switch to a different mind map
    function switchToMap(mapId) {
      // Save current map first
      saveToFirebase();
      
      // Clear current data
      nodes = {};
      edges = [];
      idCounter = 1;
      world.querySelectorAll('.node').forEach(n => n.remove());
      edgesSVG.innerHTML = '';
      clearSelection();
      
      // Set new map ID and load
      currentMapId = mapId;
      loadFromFirebase();
      hideMapManager();
    }
    
    // Create a new mind map
    function createNewMap() {
      const mapNameInput = document.getElementById('new-map-input');
      const mapName = mapNameInput.value.trim();
      
      if (!mapName) {
        alert('Please enter a name for your new mind map');
        return;
      }
      
      // Generate a unique ID for the map
      const mapId = 'map_' + Date.now();
      
      // Create initial data for the new map
      const initialData = {
        nodes: [],
        edges: [],
        idCounter: 1,
        lastUpdated: Date.now(),
        name: mapName
      };
      
      const userPath = currentUser.uid === 'guest' ? 'guest_maps' : `users/${currentUser.uid}/maps`;
      
      database.ref(`${userPath}/${mapId}`).set(initialData)
        .then(() => {
          // Add the new map to our local list
          mindMaps[mapId] = initialData;
          renderMapsList();
          
          // Clear the input field
          mapNameInput.value = '';
          
          // Switch to the new map
          switchToMap(mapId);
        })
        .catch((error) => {
          console.error('Error creating new map:', error);
          alert('Failed to create new map: ' + error.message);
        });
    }
    
    // Rename a mind map
    function renameMap(mapId) {
      const newName = prompt('Enter a new name for this mind map:', mindMaps[mapId].name || mapId);
      
      if (newName && newName.trim()) {
        const userPath = currentUser.uid === 'guest' ? 'guest_maps' : `users/${currentUser.uid}/maps`;
        
        database.ref(`${userPath}/${mapId}/name`).set(newName.trim())
          .then(() => {
            // Update local data
            mindMaps[mapId].name = newName.trim();
            renderMapsList();
          })
          .catch((error) => {
            console.error('Error renaming map:', error);
            alert('Failed to rename map: ' + error.message);
          });
      }
    }
    
    // Delete a mind map
    function deleteMap(mapId) {
      if (!confirm('Are you sure you want to delete this mind map? This action cannot be undone.')) {
        return;
      }
      
      const userPath = currentUser.uid === 'guest' ? 'guest_maps' : `users/${currentUser.uid}/maps`;
      
      database.ref(`${userPath}/${mapId}`).remove()
        .then(() => {
          // Remove from local data
          delete mindMaps[mapId];
          
          // If we're currently viewing the deleted map, switch to default
          if (currentMapId === mapId) {
            currentMapId = 'default';
            loadFromFirebase();
          }
          
          renderMapsList();
        })
        .catch((error) => {
          console.error('Error deleting map:', error);
          alert('Failed to delete map: ' + error.message);
        });
    }
    
    // Show the map manager UI
    function showMapManager() {
      loadMindMapsList();
      document.getElementById('map-manager-container').style.display = 'flex';
    }
    
    // Hide the map manager UI
    function hideMapManager() {
      document.getElementById('map-manager-container').style.display = 'none';
    }
    
    // Set up touch event listeners for mobile
    function setupTouchEvents() {
      world.addEventListener('touchstart', handleTouchStart, { passive: false });
      world.addEventListener('touchmove', handleTouchMove, { passive: false });
      world.addEventListener('touchend', handleTouchEnd);
      world.addEventListener('touchcancel', handleTouchEnd);
      
      // Prevent default touch actions on nodes to avoid browser interference
      document.addEventListener('touchstart', (e) => {
        if (e.target.closest('.node')) {
          e.preventDefault();
        }
      }, { passive: false });
    }
    
    // Handle touch start events
    function handleTouchStart(e) {
      if (e.touches.length === 1) {
        // Single touch - could be tap or pan
        const touch = e.touches[0];
        startX = touch.clientX;
        startY = touch.clientY;
        lastX = touch.clientX;
        lastY = touch.clientY;
        
        // Check if we're touching a node
        const node = document.elementFromPoint(touch.clientX, touch.clientY).closest('.node');
        if (node) {
          const nodeId = node.dataset.id;
          const nodeData = nodes[nodeId];
          
          // Start long press timer
          longPressTimer = setTimeout(() => {
            isLongPress = true;
            node.classList.add('long-press');
            showContextMenu(e, nodeData);
          }, 500);
        } else {
          // Start panning
          panning = true;
          world.style.cursor = 'grabbing';
        }
        
        // Prevent default to avoid scrolling
        e.preventDefault();
      } else if (e.touches.length === 2) {
        // Two touches - zoom gesture
        isZooming = true;
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        initialPinchDistance = Math.hypot(
          touch2.clientX - touch1.clientX,
          touch2.clientY - touch1.clientY
        );
        
        // Calculate the midpoint for zooming from center
        zoomPointX = (touch1.clientX + touch2.clientX) / 2;
        zoomPointY = (touch1.clientY + touch2.clientY) / 2;
        
        // Prevent default to avoid scrolling and browser zoom
        e.preventDefault();
      }
    }
    
    // Handle touch move events
    function handleTouchMove(e) {
      if (isLongPress) {
        // If it's a long press, don't do anything on move
        e.preventDefault();
        return;
      }
      
      if (e.touches.length === 1 && panning) {
        // Single touch moving - pan the view
        const touch = e.touches[0];
        const dx = touch.clientX - lastX;
        const dy = touch.clientY - lastY;
        
        worldX += dx / scale;
        worldY += dy / scale;
        updateWorldTransform();
        
        lastX = touch.clientX;
        lastY = touch.clientY;
        
        // Cancel long press if we moved too much
        if (Math.abs(touch.clientX - startX) > 10 || Math.abs(touch.clientY - startY) > 10) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
        }
        
        e.preventDefault();
      } else if (e.touches.length === 2 && isZooming) {
        // Two touches moving - zoom
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        const currentDistance = Math.hypot(
          touch2.clientX - touch1.clientX,
          touch2.clientY - touch1.clientY
        );
        
        if (initialPinchDistance !== null) {
          const zoomFactor = currentDistance / initialPinchDistance;
          adjustZoom(zoomFactor - 1, zoomPointX, zoomPointY);
          initialPinchDistance = currentDistance;
        }
        
        e.preventDefault();
      }
    }
    
    // Handle touch end events
    function handleTouchEnd(e) {
      // Clear long press timer
      clearTimeout(longPressTimer);
      longPressTimer = null;
      
      if (isLongPress) {
        // Reset long press state
        document.querySelectorAll('.node').forEach(n => n.classList.remove('long-press'));
        isLongPress = false;
      }
      
      if (e.touches.length === 0) {
        // No more touches - stop panning and zooming
        panning = false;
        isZooming = false;
        initialPinchDistance = null;
        world.style.cursor = 'grab';
      }
      
      // If we were dragging a node, save the new position
      if (isDraggingNode) {
        saveToFirebase();
        isDraggingNode = false;
      }
    }
    
    // Handle mouse wheel for zooming
    function handleWheel(e) {
      e.preventDefault();
      
      // Determine if this is a trackpad pinch gesture or regular scroll
      if (e.ctrlKey) {
        // Trackpad pinch gesture - adjust zoom
        const delta = -e.deltaY / 100;
        adjustZoom(delta, e.clientX, e.clientY);
      } else {
        // Regular scroll - pan the view
        worldX -= e.deltaX / scale;
        worldY -= e.deltaY / scale;
        updateWorldTransform();
      }
    }
    
    // Start panning
    function startPan(e) {
      if (e.button !== 0) return; // Only left mouse button
      if (e.target.closest('.node')) return; // Don't pan if clicking on a node
      
      panning = true;
      startX = e.clientX;
      startY = e.clientY;
      world.style.cursor = 'grabbing';
    }
    
    // Handle panning
    function handlePan(e) {
      if (!panning) return;
      
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      
      worldX += dx / scale;
      worldY += dy / scale;
      updateWorldTransform();
      
      startX = e.clientX;
      startY = e.clientY;
    }
    
    // Stop panning
    function stopPan() {
      panning = false;
      world.style.cursor = 'grab';
    }
    
    // Adjust zoom level
    function adjustZoom(delta, clientX, clientY) {
      // Calculate the point in world coordinates before zoom
      const rect = world.getBoundingClientRect();
      const worldXBefore = (clientX - rect.left - worldX * scale) / scale;
      const worldYBefore = (clientY - rect.top - worldY * scale) / scale;
      
      // Adjust the scale
      const newScale = Math.max(0.1, Math.min(5, scale + delta));
      
      // Only update if scale actually changed
      if (newScale !== scale) {
        scale = newScale;
        
        // Calculate the new world position to keep the point under the cursor fixed
        worldX = (clientX - rect.left - worldXBefore * scale) / scale;
        worldY = (clientY - rect.top - worldYBefore * scale) / scale;
        
        updateWorldTransform();
        updateZoomDisplay();
      }
    }
    
    // Update the world transform with current pan and zoom
    function updateWorldTransform() {
      world.style.transform = `translate(${worldX * scale}px, ${worldY * scale}px) scale(${scale})`;
    }
    
    // Reset view to default zoom and position
    function resetView() {
      scale = 1;
      worldX = 0;
      worldY = 0;
      updateWorldTransform();
      updateZoomDisplay();
    }
    
    // Update the zoom display
    function updateZoomDisplay() {
      document.getElementById('zoom-display').textContent = `${Math.round(scale * 100)}%`;
    }
    
    // Add a new node
    function addNode(x, y, text) {
      const id = idCounter++;
      const node = document.createElement('div');
      node.className = 'node';
      node.dataset.id = id;
      node.innerHTML = `<div class="node-content">${text}</div>`;
      node.style.left = `${x}px`;
      node.style.top = `${y}px`;
      
      // Add event listeners
      node.addEventListener('mousedown', startNodeDrag);
      node.addEventListener('touchstart', handleNodeTouchStart, { passive: false });
      node.addEventListener('click', handleNodeClick);
      
      world.appendChild(node);
      
      // Store node data
      nodes[id] = { id, x, y, text, color: '#333' };
      return id;
    }
    
    // Start dragging a node
    function startNodeDrag(e) {
      if (e.button !== 0) return; // Only left mouse button
      
      const node = e.currentTarget;
      const nodeId = node.dataset.id;
      const nodeData = nodes[nodeId];
      
      // Select the node
      selectNode(nodeId);
      
      // Calculate offset from mouse to node top-left corner
      const offsetX = e.clientX - nodeData.x * scale - worldX * scale;
      const offsetY = e.clientY - nodeData.y * scale - worldY * scale;
      
      // Function to handle dragging
      function handleDrag(e) {
        // Calculate new position in world coordinates
        const newX = (e.clientX - offsetX - worldX * scale) / scale;
        const newY = (e.clientY - offsetY - worldY * scale) / scale;
        
        // Update node position
        nodeData.x = newX;
        nodeData.y = newY;
        node.style.left = `${newX}px`;
        node.style.top = `${newY}px`;
        
        // Update connections
        updateConnections();
      }
      
      // Function to stop dragging
      function stopDrag() {
        document.removeEventListener('mousemove', handleDrag);
        document.removeEventListener('mouseup', stopDrag);
        node.classList.remove('dragging');
        isDraggingNode = true;
      }
      
      // Add event listeners
      document.addEventListener('mousemove', handleDrag);
      document.addEventListener('mouseup', stopDrag);
      
      // Add dragging class
      node.classList.add('dragging');
      
      // Prevent text selection during drag
      e.preventDefault();
    }
    
    // Handle node touch start for mobile
    function handleNodeTouchStart(e) {
      if (e.touches.length !== 1) return;
      
      const node = e.currentTarget;
      const nodeId = node.dataset.id;
      const nodeData = nodes[nodeId];
      const touch = e.touches[0];
      
      // Select the node
      selectNode(nodeId);
      
      // Calculate offset from touch to node top-left corner
      const offsetX = touch.clientX - nodeData.x * scale - worldX * scale;
      const offsetY = touch.clientY - nodeData.y * scale - worldY * scale;
      
      // Function to handle dragging
      function handleTouchDrag(e) {
        if (e.touches.length !== 1) return;
        
        const touch = e.touches[0];
        
        // Calculate new position in world coordinates
        const newX = (touch.clientX - offsetX - worldX * scale) / scale;
        const newY = (touch.clientY - offsetY - worldY * scale) / scale;
        
        // Update node position
        nodeData.x = newX;
        nodeData.y = newY;
        node.style.left = `${newX}px`;
        node.style.top = `${newY}px`;
        
        // Update connections
        updateConnections();
        
        // Prevent default to avoid scrolling
        e.preventDefault();
      }
      
      // Function to stop dragging
      function stopTouchDrag() {
        document.removeEventListener('touchmove', handleTouchDrag);
        document.removeEventListener('touchend', stopTouchDrag);
        document.removeEventListener('touchcancel', stopTouchDrag);
        node.classList.remove('dragging');
        isDraggingNode = true;
      }
      
      // Add event listeners
      document.addEventListener('touchmove', handleTouchDrag, { passive: false });
      document.addEventListener('touchend', stopTouchDrag);
      document.addEventListener('touchcancel', stopTouchDrag);
      
      // Add dragging class
      node.classList.add('dragging');
      
      // Prevent default to avoid long press context menu
      e.preventDefault();
    }
    
    // Handle node click
    function handleNodeClick(e) {
      const nodeId = e.currentTarget.dataset.id;
      
      if (connectMode) {
        if (!connectFrom) {
          // First node in connection
          connectFrom = nodeId;
          e.currentTarget.classList.add('selected');
        } else if (connectFrom !== nodeId) {
          // Second node in connection - create connection
          addConnection(connectFrom, nodeId);
          connectFrom = null;
          connectMode = false;
          document.getElementById('connectBtn').classList.remove('active');
          clearSelection();
          saveToFirebase(); // Auto-save after creating connection
        }
      } else if (editMode) {
        // Edit node
        selectNode(nodeId);
        showEditPanel(nodes[nodeId]);
        editMode = false;
        document.getElementById('editBtn').classList.remove('active');
      } else {
        // Regular selection
        selectNode(nodeId);
      }
      
      // Don't propagate to prevent clearing selection
      e.stopPropagation();
    }
    
    // Select a node
    function selectNode(nodeId) {
      clearSelection();
      selectedNode = nodeId;
      nodes[nodeId].el.classList.add('selected');
    }
    
    // Clear selection
    function clearSelection() {
      if (selectedNode) {
        nodes[selectedNode].el.classList.remove('selected');
      }
      selectedNode = null;
      connectFrom = null;
    }
    
    // Add a connection between two nodes
    function addConnection(fromId, toId) {
      // Check if connection already exists
      if (edges.some(edge => edge.from === fromId && edge.to === toId)) {
        return;
      }
      
      edges.push({ from: fromId, to: toId });
      updateConnections();
    }
    
    // Update all connections in the SVG
    function updateConnections() {
      // Clear existing connections
      edgesSVG.innerHTML = '';
      
      // Draw new connections
      edges.forEach(edge => {
        const fromNode = nodes[edge.from];
        const toNode = nodes[edge.to];
        
        if (!fromNode || !toNode) return;
        
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('class', 'connection');
        line.setAttribute('x1', fromNode.x + fromNode.el.offsetWidth / 2);
        line.setAttribute('y1', fromNode.y + fromNode.el.offsetHeight / 2);
        line.setAttribute('x2', toNode.x + toNode.el.offsetWidth / 2);
        line.setAttribute('y2', toNode.y + toNode.el.offsetHeight / 2);
        
        // Highlight if connected to selected node
        if (selectedNode && (edge.from === selectedNode || edge.to === selectedNode)) {
          line.classList.add('highlight');
        }
        
        edgesSVG.appendChild(line);
      });
    }
    
    // Delete selected node or connection
    function deleteSelected() {
      if (selectedNode) {
        // Delete node and its connections
        delete nodes[selectedNode].el;
        delete nodes[selectedNode];
        
        // Remove any connections to/from this node
        edges = edges.filter(edge => edge.from !== selectedNode && edge.to !== selectedNode);
        
        // Update connections
        updateConnections();
        
        // Clear selection
        clearSelection();
      }
    }
    
    // Show color menu
    function showColorMenu(e) {
      // Create color picker menu
      hideContextMenu();
      
      const menu = document.createElement('div');
      menu.className = 'context-menu';
      menu.innerHTML = `
        <div class="color-picker">
          <div class="color-option" style="background: #2ecc71;" data-color="#2ecc71"></div>
          <div class="color-option" style="background: #3498db;" data-color="#3498db"></div>
          <div class="color-option" style="background: #e74c3c;" data-color="#e74c3c"></div>
          <div class="color-option" style="background: #f1c40f;" data-color="#f1c40f"></div>
          <div class="color-option" style="background: #9b59b6;" data-color="#9b59b6"></div>
          <div class="color-option" style="background: #1abc9c;" data-color="#1abc9c"></div>
          <div class="color-option" style="background: #e67e22;" data-color="#e67e22"></div>
          <div class="color-option" style="background: #34495e;" data-color="#34495e"></div>
          <div class="color-option" style="background: #95a5a6;" data-color="#95a5a6"></div>
          <div class="color-option" style="background: #d35400;" data-color="#d35400"></div>
          <div class="color-option" style="background: #c0392b;" data-color="#c0392b"></div>
          <div class="color-option" style="background: #16a085;" data-color="#16a085"></div>
        </div>
      `;
      
      // Position menu near button
      menu.style.left = e.clientX + 'px';
      menu.style.top = e.clientY + 'px';
      
      // Add event listeners to color options
      menu.querySelectorAll('.color-option').forEach(option => {
        option.addEventListener('click', () => {
          if (selectedNode) {
            const color = option.dataset.color;
            nodes[selectedNode].el.style.background = color;
            nodes[selectedNode].color = color;
            saveToFirebase(); // Auto-save after color change
          }
          hideContextMenu();
        });
      });
      
      document.body.appendChild(menu);
      
      // Close menu when clicking elsewhere
      setTimeout(() => {
        document.addEventListener('click', hideContextMenu, { once: true });
      }, 0);
    }
    
    // Handle context menu
    function handleContextMenu(e) {
      e.preventDefault();
      
      const node = e.target.closest('.node');
      if (node) {
        const nodeId = node.dataset.id;
        selectNode(nodeId);
        showContextMenu(e, nodes[nodeId]);
      }
    }
    
    // Show context menu for a node
    function showContextMenu(e, nodeData) {
      hideContextMenu();
      
      const menu = document.createElement('div');
      menu.className = 'context-menu';
      menu.innerHTML = `
        <div class="context-menu-item" data-action="edit">Edit</div>
        <div class="context-menu-item" data-action="delete">Delete</div>
        <div class="context-menu-item" data-action="color">Change Color</div>
      `;
      
      // Position menu at cursor
      menu.style.left = e.clientX + 'px';
      menu.style.top = e.clientY + 'px';
      
      // Add event listeners
      menu.querySelectorAll('.context-menu-item').forEach(item => {
        item.addEventListener('click', () => {
          const action = item.dataset.action;
          switch (action) {
            case 'edit':
              showEditPanel(nodeData);
              break;
            case 'delete':
              deleteSelected();
              saveToFirebase(); // Auto-save after deletion
              break;
            case 'color':
              showColorMenu(e);
              break;
          }
        });
      });
      
      document.body.appendChild(menu);
      
      // Close menu when clicking elsewhere
      setTimeout(() => {
        document.addEventListener('click', hideContextMenu, { once: true });
      }, 0);
    }
    
    // Hide context menu
    function hideContextMenu() {
      document.querySelectorAll('.context-menu').forEach(menu => menu.remove());
    }
    
    // Show edit panel for a node
    function showEditPanel(nodeData) {
      document.getElementById('edit-textarea').value = nodeData.text;
      document.getElementById('edit-panel').style.display = 'block';
      document.getElementById('overlay').style.display = 'block';
      
      // Store reference to the node being edited
      activeEditInput = nodeData;
    }
    
    // Close edit panel
    function closeEditPanel() {
      document.getElementById('edit-panel').style.display = 'none';
      document.getElementById('overlay').style.display = 'none';
      activeEditInput = null;
    }
    
    // Save changes from edit panel
    function saveEditPanel() {
      if (activeEditInput) {
        const newText = document.getElementById('edit-textarea').value;
        activeEditInput.text = newText;
        activeEditInput.el.querySelector('.node-content').textContent = newText;
        closeEditPanel();
      }
    }
    
    // Export data as JSON
    function exportData() {
      const data = {
        nodes: Object.values(nodes),
        edges: edges,
        idCounter: idCounter
      };
      
      const dataStr = JSON.stringify(data);
      const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
      
      const exportFileDefaultName = 'mindmap.json';
      
      const linkElement = document.createElement('a');
      linkElement.setAttribute('href', dataUri);
      linkElement.setAttribute('download', exportFileDefaultName);
      linkElement.click();
    }
    
    // Create import input if it doesn't exist
    function createImportInput() {
      const input = document.createElement('input');
      input.type = 'file';
      input.id = 'importInput';
      input.accept = '.json';
      input.style.display = 'none';
      input.onchange = handleImport;
      
      document.body.appendChild(input);
      input.click();
    }
    
    // Handle import file selection
    function handleImport(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          loadData(data);
          saveToFirebase(); // Save imported data to cloud
        } catch (error) {
          alert('Error parsing JSON file: ' + error.message);
        }
      };
      reader.readAsText(file);
      
      // Clean up
      e.target.remove();
    }
    
    // Load data from JSON
    function loadData(data) {
      // Clear existing data
      nodes = {};
      edges = [];
      idCounter = data.idCounter || 1;
      world.querySelectorAll('.node').forEach(n => n.remove());
      edgesSVG.innerHTML = '';
      clearSelection();
      
      // Create nodes
      data.nodes.forEach(nodeData => {
        const node = document.createElement('div');
        node.className = 'node';
        node.dataset.id = nodeData.id;
        node.innerHTML = `<div class="node-content">${nodeData.text}</div>`;
        node.style.left = `${nodeData.x}px`;
        node.style.top = `${nodeData.y}px`;
        
        if (nodeData.color) {
          node.style.background = nodeData.color;
        }
        
        // Add event listeners
        node.addEventListener('mousedown', startNodeDrag);
        node.addEventListener('touchstart', handleNodeTouchStart, { passive: false });
        node.addEventListener('click', handleNodeClick);
        
        world.appendChild(node);
        
        // Store node data with element reference
        nodes[nodeData.id] = {
          ...nodeData,
          el: node
        };
      });
      
      // Create edges
      edges = data.edges || [];
      updateConnections();
    }
    
    // Search nodes
    function searchNodes(query) {
      if (!query) {
        // Reset all nodes
        Object.values(nodes).forEach(node => {
          node.el.style.opacity = '1';
          node.el.style.zIndex = '1';
        });
        return;
      }
      
      const lowerQuery = query.toLowerCase();
      
      Object.values(nodes).forEach(node => {
        if (node.text.toLowerCase().includes(lowerQuery)) {
          node.el.style.opacity = '1';
          node.el.style.zIndex = '2';
        } else {
          node.el.style.opacity = '0.3';
          node.el.style.zIndex = '1';
        }
      });
    }
    
    // Apply layout to nodes
    function applyLayout(type) {
      const centerX = 500;
      const centerY = 500;
      const nodeValues = Object.values(nodes);
      
      if (type === 'horizontal') {
        // Horizontal tree layout
        nodeValues.forEach((node, i) => {
          node.x = centerX + (i - nodeValues.length / 2) * 200;
          node.y = centerY;
          node.el.style.left = `${node.x}px`;
          node.el.style.top = `${node.y}px`;
        });
      } else if (type === 'vertical') {
        // Vertical tree layout
        nodeValues.forEach((node, i) => {
          node.x = centerX;
          node.y = centerY + (i - nodeValues.length / 2) * 100;
          node.el.style.left = `${node.x}px`;
          node.el.style.top = `${node.y}px`;
        });
      } else if (type === 'radial') {
        // Radial layout
        const radius = 300;
        const angleStep = (2 * Math.PI) / nodeValues.length;
        
        nodeValues.forEach((node, i) => {
          const angle = i * angleStep;
          node.x = centerX + radius * Math.cos(angle);
          node.y = centerY + radius * Math.sin(angle);
          node.el.style.left = `${node.x}px`;
          node.el.style.top = `${node.y}px`;
        });
      }
      
      // Update connections
      updateConnections();
      
      // Reset layout dropdown
      document.getElementById('layoutBtn').value = '';
    }
    
    // Initialize the app
    init();
  </script>
</body>
</html>